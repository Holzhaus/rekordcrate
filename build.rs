use glob::glob;
use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    // Make cargo rerun the build script if the data directory changes.
    println!("cargo:rerun-if-changed=data");

    let out_dir = env::var("OUT_DIR").unwrap();
    let out_dir = Path::new(&out_dir);
    eprintln!("Writing tests to: {:?}", out_dir);
    write_pdb_tests(out_dir);
    write_anlz_tests(out_dir);
    write_setting_tests(out_dir);
}

fn write_pdb_tests(output_path: &Path) {
    let output_filepath = output_path.join("tests_pdb.rs");
    let mut output_file = File::create(&output_filepath).unwrap();

    write!(
        output_file,
        r#"// THIS FILE IS AUTOGENERATED - DO NOT EDIT!
use rekordcrate::pdb::{{Header, RowGroup}};
"#
    )
    .unwrap();

    glob("data/*/PIONEER/rekordbox/export.pdb")
        .expect("failed to read glob pattern")
        .map(|entry| entry.unwrap())
        .for_each(|path| {
            let name = path
                .iter()
                .enumerate()
                .filter_map(|(i, component)| {
                    [1, 4]
                        .contains(&i)
                        .then(|| component)
                        .and_then(|component| component.to_str())
                })
                .collect::<Vec<&str>>()
                .join("_")
                .replace(".", "_");
            eprintln!("Writing pdb test: {:?}", name);
            write!(
                output_file,
                include_str!("./tests/tests_pdb.rs.in"),
                name = name,
                filepath = path.canonicalize().unwrap().to_str().unwrap(),
            )
            .unwrap();
        });
}

fn write_anlz_tests(output_path: &Path) {
    let output_filepath = output_path.join("tests_anlz.rs");
    let mut output_file = File::create(&output_filepath).unwrap();

    write!(
        output_file,
        r#"// THIS FILE IS AUTOGENERATED - DO NOT EDIT!
use rekordcrate::anlz::ANLZ;
"#
    )
    .unwrap();

    glob("data/*/PIONEER/USBANLZ/*/*/ANLZ*.*")
        .expect("failed to read glob pattern")
        .map(|entry| entry.unwrap())
        .for_each(|path| {
            let name = path
                .iter()
                .enumerate()
                .filter_map(|(i, component)| {
                    [1, 4, 5, 6]
                        .contains(&i)
                        .then(|| component)
                        .and_then(|component| component.to_str())
                })
                .collect::<Vec<&str>>()
                .join("_")
                .replace(".", "_");
            eprintln!("Writing anlz test: {:?}", name);
            write!(
                output_file,
                include_str!("./tests/tests_anlz.rs.in"),
                name = name,
                filepath = path.canonicalize().unwrap().to_str().unwrap(),
            )
            .unwrap();
        });
}

fn write_setting_tests(output_path: &Path) {
    let output_filepath = output_path.join("tests_setting.rs");
    let mut output_file = File::create(&output_filepath).unwrap();

    write!(
        output_file,
        r#"// THIS FILE IS AUTOGENERATED - DO NOT EDIT!
use rekordcrate::setting::Setting;
"#
    )
    .unwrap();

    glob("data/*/PIONEER/*.DAT")
        .expect("failed to read glob pattern")
        .map(|entry| entry.unwrap())
        .for_each(|path| {
            let name = path
                .iter()
                .enumerate()
                .filter_map(|(i, component)| {
                    [1, 3]
                        .contains(&i)
                        .then(|| component)
                        .and_then(|component| component.to_str())
                })
                .collect::<Vec<&str>>()
                .join("_")
                .replace(".", "_");
            eprintln!("Writing setting test: {:?}", name);
            write!(
                output_file,
                include_str!("./tests/tests_setting.rs.in"),
                name = name,
                filepath = path.canonicalize().unwrap().to_str().unwrap(),
            )
            .unwrap();
        });
}
