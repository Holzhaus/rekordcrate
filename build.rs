use std::env;
use std::fs::read_dir;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    // Make cargo rerun the build script if the data directory changes.
    println!("cargo:rerun-if-changed=data");

    let out_dir = env::var("OUT_DIR").unwrap();
    let out_dir = Path::new(&out_dir);
    eprintln!("Writing tests to: {:?}", out_dir);
    write_pdb_tests(out_dir);
    write_anlz_tests(out_dir);
    write_setting_tests(out_dir);
}

fn write_pdb_tests(output_path: &Path) {
    let output_filepath = output_path.join("tests_pdb.rs");
    let mut output_file = File::create(&output_filepath).unwrap();

    write!(
        output_file,
        r#"// THIS FILE IS AUTOGENERATED - DO NOT EDIT!
use rekordcrate::pdb::{{Header, RowGroup}};
"#
    )
    .unwrap();

    read_dir("./data/")
        .expect("Failed to read directory")
        .map(|x| {
            let path = x.unwrap();
            (path.file_name(), path.path())
        })
        .for_each(|(name, mut path)| {
            path.push("PIONEER");
            path.push("rekordbox");
            path.push("export");
            path.set_extension("pdb");
            eprintln!("Writing pdb test: {:?}", name);

            write!(
                output_file,
                include_str!("./tests/tests_pdb.rs.in"),
                name = name.to_str().unwrap(),
                filepath = path.canonicalize().unwrap().to_str().unwrap(),
            )
            .unwrap();
        });
}

fn write_anlz_tests(output_path: &Path) {
    let output_filepath = output_path.join("tests_anlz.rs");
    let mut output_file = File::create(&output_filepath).unwrap();

    write!(
        output_file,
        r#"// THIS FILE IS AUTOGENERATED - DO NOT EDIT!
use rekordcrate::anlz::ANLZ;
"#
    )
    .unwrap();

    read_dir("./data/")
        .expect("Failed to read directory")
        .map(|x| x.unwrap())
        .filter_map(|entry| {
            let name = entry.file_name().to_str().unwrap().to_owned();
            let mut path = entry.path().canonicalize().unwrap();
            path.push("PIONEER");
            path.push("USBANLZ");
            let entries = path.read_dir();
            entries.map_or(None, |x| Some((name, x)))
        })
        .flat_map(|(name, entries)| {
            entries.map(|x| x.unwrap()).map(move |entry| {
                let new_name = entry.file_name().to_str().unwrap().to_owned();
                let path = entry.path();
                (format!("{}_{}", name, new_name), path)
            })
        })
        .flat_map(|(name, entries)| {
            entries
                .read_dir()
                .expect("Failed to read directory")
                .map(|x| x.unwrap())
                .map(move |entry| {
                    let new_name = entry.file_name().to_str().unwrap().to_owned();
                    let path = entry.path();
                    (format!("{}_{}", name, new_name), path)
                })
        })
        .flat_map(|(name, entries)| {
            entries
                .read_dir()
                .expect("Failed to read directory")
                .map(|x| x.unwrap())
                .map(move |entry| {
                    let new_name = entry
                        .file_name()
                        .to_str()
                        .unwrap()
                        .to_owned()
                        .replace(".", "_");
                    let path = entry.path();
                    (format!("{}_{}", name, new_name), path)
                })
        })
        .for_each(|(name, path)| {
            eprintln!("Writing anlz test: {:?}", name);
            write!(
                output_file,
                include_str!("./tests/tests_anlz.rs.in"),
                name = name,
                filepath = path.canonicalize().unwrap().to_str().unwrap(),
            )
            .unwrap();
        });
}

fn write_setting_tests(output_path: &Path) {
    let output_filepath = output_path.join("tests_setting.rs");
    let mut output_file = File::create(&output_filepath).unwrap();

    write!(
        output_file,
        r#"// THIS FILE IS AUTOGENERATED - DO NOT EDIT!
use rekordcrate::setting::Setting;
"#
    )
    .unwrap();

    read_dir("./data/")
        .expect("Failed to read directory")
        .map(|x| x.unwrap())
        .filter_map(|entry| {
            let name = entry.file_name().to_str().unwrap().to_owned();
            let mut path = entry.path().canonicalize().unwrap();
            path.push("PIONEER");
            let entries = path.read_dir();
            entries.map_or(None, |x| Some((name, x)))
        })
        .flat_map(|(name, entries)| {
            entries
                .filter_map(move |entry| {
                    let entry = entry.ok();
                    entry
                        .as_ref()
                        .and_then(|x| x.file_type().ok())
                        .and_then(|x| x.is_file().then(move || entry.unwrap()))
                })
                .filter(|entry| {
                    entry
                        .file_name()
                        .to_str()
                        .map_or(false, |file_name| file_name.ends_with(".DAT"))
                })
                .map(move |entry| {
                    let new_name = entry
                        .file_name()
                        .to_str()
                        .unwrap()
                        .rsplit_once(".")
                        .unwrap()
                        .0
                        .to_owned();
                    let path = entry.path();
                    (format!("{}_{}", name, new_name), path)
                })
        })
        .for_each(|(name, path)| {
            eprintln!("Writing setting test: {:?}", name);
            write!(
                output_file,
                include_str!("./tests/tests_setting.rs.in"),
                name = name,
                filepath = path.canonicalize().unwrap().to_str().unwrap(),
            )
            .unwrap();
        });
}
